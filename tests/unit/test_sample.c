#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "definitions.h"
#include "pe.h"
#include "runtime.h"
#include "multivariate_normal.h"
#include "logistic_regression.h"
#include "prior.h"
#include "data_input.h"
#include "chain.h"
#include "sample.h"
#include "tests.h"

static int test_sample_rt_default(pe_t *pe);
static int test_sample_rt(pe_t *pe);
static int test_sample_init(pe_t *pe);
static int test_sample_propose_mvnb(pe_t *pe);
static int test_sample_evaluate_lr(pe_t *pe);
static int test_sample_choose(pe_t *pe);

int test_sample_suite(void){

  pe_t *pe = NULL;

  pe_create(MPI_COMM_WORLD, PE_QUIET, &pe);
  assert(pe);
  test_assert(1);

  test_sample_rt_default(pe);
  test_sample_rt(pe);
  test_sample_init(pe);
  test_sample_propose_mvnb(pe);
  test_sample_evaluate_lr(pe);
  test_sample_choose(pe);

  pe_info(pe, "PASS\t./unit/test_sample\n");
  pe_free(pe);

  return 0;
}

static int test_sample_rt_default(pe_t *pe){

  assert(pe);

  int dim;
  precision *values = NULL;

  rt_t *rt = NULL;
  sample_t *sample = NULL;

  rt_create(pe, &rt);
  assert(rt);

  sample_create(pe, &sample);
  assert(sample);
  test_assert(1);

  sample_dim(sample, &dim);
  test_assert(dim == 3);
  sample_values(sample, &values);
  test_assert(values == NULL);

  sample_free(sample);
  rt_free(rt);

  return 0;
}

static int test_sample_rt(pe_t *pe){

  assert(pe);

  int dim;
  precision *values = NULL;

  rt_t *rt = NULL;
  sample_t *sample = NULL;

  rt_create(pe, &rt);
  assert(rt);
  rt_read_input_file(rt, "test.dat");

  sample_create(pe, &sample);
  assert(sample);
  test_assert(1);

  /* testing sample runtime init */
  sample_init_rt(rt, sample);

  sample_dim(sample, &dim);
  test_assert(dim == 3);
  sample_values(sample, &values);
  test_assert(values != NULL);

  sample_free(sample);
  rt_free(rt);

  return 0;
}

static int test_sample_init(pe_t *pe){

  assert(pe);

  int dim, i;
  precision *values = NULL;

  rt_t *rt = NULL;
  sample_t *sample = NULL;

  rt_create(pe, &rt);
  assert(rt);

  sample_create(pe, &sample);
  assert(sample);
  test_assert(1);

  /* testing sample runtime init */
  sample_init_rt(rt, sample);

  sample_dim(sample, &dim);
  sample_values(sample, &values);

  sample_init_zero(sample);

  for(i=0; i<dim; i++)
    test_assert(fabs(values[i] - 0.0) < TEST_PRECISION_TOLERANCE);

  sample_free(sample);
  rt_free(rt);

  return 0;
}

static int test_sample_propose_mvnb(pe_t *pe){

  assert(pe);

  int dim=3, i;
  precision *sample = NULL;

  rt_t *rt = NULL;
  mvnb_t *mvnb = NULL;
  sample_t *cur = NULL;
  sample_t *pro = NULL;

  /*
   * Default gaussian samples generated by ran_serial_gaussian.
   * Assumes default seed of 7361237
   */
  precision sample_ref[3] = {-1.3592500859686045, -1.2025451186911100, 0.4833644037824572};

  rt_create(pe, &rt);
  assert(rt);

  mvn_block_create(pe, &mvnb);
  assert(mvnb);
  test_assert(1);

  sample_create(pe, &cur);
  assert(cur);
  test_assert(1);

  sample_create(pe, &pro);
  assert(pro);
  test_assert(1);

  mvn_block_dim_set(mvnb, dim);
  mvn_block_init_rt(rt, mvnb);
  mvn_block_init(mvnb);

  sample_dim_set(cur, dim);
  sample_init_rt(rt, cur);
  sample_init_zero(cur);

  sample_dim_set(pro, dim);
  sample_init_rt(rt, pro);
  sample_init_zero(pro);
  sample_values(pro, &sample);

  /* Generate actual sample*/
  sample_propose_mvnb(mvnb, cur, pro);

  for(i=0; i<dim; i++)
    test_assert(fabs(sample[i] - sample_ref[i]) < TEST_PRECISION_TOLERANCE);

  mvn_block_free(mvnb);
  sample_free(cur);
  sample_free(pro);
  rt_free(rt);

  return 0;
}

static int test_sample_evaluate_lr(pe_t *pe){

  assert(pe);

  int dimx=3, dimy=1, N=5;
  int i,j;

  rt_t *rt = NULL;
  lr_t *lr = NULL;
  data_t *data = NULL;
  sample_t *cur = NULL;
  sample_t *pro = NULL;

  precision x_ref[15] = {1.0000000000000000,1.4648106502470808,-1.5701058145856399,
                         1.0000000000000000,1.5407782876057425,-0.5819483312184370,
                         1.0000000000000000,0.1415183428679135,0.5459865569896000,
                         1.0000000000000000,0.4670300843306030,1.1185017644967441,
                         1.0000000000000000,1.6517639463377001,1.5968332608405691};

  int y_ref[5] = {-1.0000000000000000,
                  -1.0000000000000000,
                  -1.0000000000000000,
                  1.0000000000000000,
                  -1.0000000000000000};

  precision prior_test, prior_cur=0.0, prior_pro=0.0;
  precision lhood_test, lhood_cur = 0.0, lhood_pro=0.0;
  precision posterior_test, posterior_cur = 0.0, posterior_pro=0.0;
  precision ratio_ref, ratio_act;

  precision sample_cur[3] = {0.0, 0.0, 0.0};
  precision sample_pro[3] = {-10.0000000000000000, 5.0000000000000000, 10.0000000000000000};
  precision *x = (precision*) malloc(dimx * N * sizeof(precision));
  int *y = (int*) malloc(dimy * N * sizeof(int));

  rt_create(pe, &rt);
  assert(rt);

  data_create_train(pe, &data);
  assert(data);
  test_assert(1);

  /* Initialize data struct */
  data_dimx_set(data, dimx);
  data_dimy_set(data, dimy);
  data_N_set(data, N);
  data_x_set(data, x);
  data_y_set(data, y);

  /* Copy reference data */
  for(i=0; i<N; i++)
  {
    for(j=0; j<dimx; j++)
    {
      x[i*dimx+j] = x_ref[i*dimx+j];
    }
    y[i] = y_ref[i];
  }

  lr_lhood_create(pe, data, &lr);
  assert(lr);
  test_assert(1);

  sample_create(pe, &cur);
  assert(cur);
  test_assert(1);

  sample_create(pe, &pro);
  assert(pro);
  test_assert(1);

  sample_dim_set(cur, dimx);
  sample_init_rt(rt, cur);
  sample_init_zero(cur);
  sample_copy_values(cur, sample_cur);

  sample_dim_set(pro, dimx);
  sample_init_rt(rt, pro);
  sample_init_zero(pro);
  sample_copy_values(pro, sample_pro);

  /* Get reference prior, lhood */
  prior_cur = pr_log_prob(sample_cur, dimx);
  lhood_cur = lr_lhood(lr, sample_cur);
  posterior_cur = prior_cur + lhood_cur;
  sample_posterior_set(cur, posterior_cur);

  prior_pro = pr_log_prob(sample_pro, dimx);
  lhood_pro = lr_lhood(lr, sample_pro);
  posterior_pro = prior_pro+lhood_pro;
  sample_posterior_set(pro, posterior_pro);

  ratio_ref = exp(posterior_pro - posterior_cur);
  ratio_act = sample_evaluate_lr(lr, cur, pro);
  test_assert(fabs(ratio_ref - ratio_act) < TEST_PRECISION_TOLERANCE);
  sample_prior(pro, &prior_test);
  test_assert(fabs(prior_test - prior_pro) < TEST_PRECISION_TOLERANCE);
  sample_likelihood(pro, &lhood_test);
  test_assert(fabs(lhood_test - lhood_pro) < TEST_PRECISION_TOLERANCE);
  sample_posterior(pro, &posterior_test);
  test_assert(fabs(posterior_test - posterior_pro) < TEST_PRECISION_TOLERANCE);

  /* Check if when ratio is larger than 1 is casted to 1 */
  /* i.e feed back the obtained proposed posterior times 10 as current */
  sample_posterior_set(cur, posterior_pro*10);
  ratio_act = sample_evaluate_lr(lr, cur, pro);
  test_assert(fabs(1.0 - ratio_act) < TEST_PRECISION_TOLERANCE);

  sample_free(cur);
  sample_free(pro);
  data_free(data);
  lr_lhood_free(lr);
  rt_free(rt);

  return 0;
}

static int test_sample_choose(pe_t *pe){

  assert(pe);

  int dim=3, N=5;
  int i, idx;

  rt_t *rt = NULL;
  ch_t *chain = NULL;
  sample_t *cur = NULL;
  sample_t *pro = NULL;

  precision *samples = NULL;
  precision *probability = NULL;
  precision *ratio = NULL;
  int *accepted = NULL;

  precision sample_cur[3] = {1.0, 2.0, 3.0};
  precision sample_pro[3] = {-10.0000000000000000, 5.0000000000000000, 10.0000000000000000};

  rt_create(pe, &rt);
  assert(rt);

  ch_create(pe, &chain);
  assert(chain);
  test_assert(1);

  sample_create(pe, &cur);
  assert(cur);
  test_assert(1);

  sample_create(pe, &pro);
  assert(pro);
  test_assert(1);

  sample_dim_set(cur, dim);
  sample_init_rt(rt, cur);
  sample_init_zero(cur);
  sample_copy_values(cur, sample_cur);

  sample_dim_set(pro, dim);
  sample_init_rt(rt, pro);
  sample_init_zero(pro);
  sample_copy_values(pro, sample_pro);

  ch_dim_set(chain, dim);
  ch_N_set(chain, N);
  ch_init_chain_rt(rt, chain);

  ch_samples(chain, &samples);
  ch_probability(chain, &probability);
  ch_ratio(chain, &ratio);
  ch_accepted(chain, &accepted);

  /* Initialize chain for 5 iterations
  *
  */
  for(i=0; i<N+1; i++) ch_init_stats(i, chain);

  sample_t *pcur = cur;
  sample_t *ppro = pro;
  /* Check one sample is rejected (set acceptance to 0)
  * pointer are not swapped
  * current sample is appended
  * accepted is set to 0
  * stats are appended
  */
  idx = 2;
  ch_append_probability(idx, 0.0, chain); /* sample should be rejected */
  sample_choose(idx, chain, &cur, &pro);
  test_assert(cur == pcur); /* Check swap did not happen */
  test_assert(pro == ppro); /* Check swap did not happen */
  test_assert(accepted[idx] == 0);
  for(i=0; i<dim; i++)
    test_assert(fabs(samples[idx*dim+i] - sample_cur[i]) < TEST_PRECISION_TOLERANCE);

  /* To avoid printing on screen, test will start from iter=2*/
  /* Check one sample is accepted (set acceptance to 1)
  * pointer are swapped
  * proposed sample is appended
  * accepted is set to 1
  * stats are appended
  */
  idx = 3;
  ch_append_probability(idx, 1.0, chain); /* sample should be accepted */
  sample_choose(idx, chain, &cur, &pro);
  test_assert(cur == ppro); /* Check swap */
  test_assert(pro == pcur); /* Check swap */
  test_assert(accepted[idx] == 1);
  test_assert(fabs(ratio[idx] - 1.0/(precision)idx) < TEST_PRECISION_TOLERANCE);
  for(i=0; i<dim; i++)
    test_assert(fabs(samples[idx*dim+i] - sample_pro[i]) < TEST_PRECISION_TOLERANCE);

  ch_free(chain);
  sample_free(cur);
  sample_free(pro);
  rt_free(rt);

  return 0;
}
